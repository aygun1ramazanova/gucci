var XG_DEBUG = true;
var hasTheirRendered = false;

(function () {
	/*if (
		!window.location.pathname.startsWith('/us/en') &&
		!window.location.pathname.startsWith('/uk/en_gb') &&
		!window.location.pathname.startsWith('/jp/ja') &&
		!(window.location.host.includes('dev-kowa.edge.regiongold.com') && window.location.pathname.startsWith('/it/it')) &&
		!(window.location.host.includes('qa1.edge.regiongold.com') && window.location.pathname.startsWith('/it/it'))
	)
		return;*/

	if (window.isXgenLoadedAlready) {
		return false;
	}

	window.isXgenLoadedAlready = true;

	let xgenRecsData;

	function getAbGroupForXgen() {
		try {
			const getExperimentId = () => {
				const data = window.optimizely.get('data').experiments;
				const testName = window.location.pathname.includes('us/en')
					? '[PROD] US - Recommendations POC - Third Iteration'
					: '[PROD] UK - Recommendations XGen/Google/Algolia';
				for (let expId of Object.keys(data)) {
					if (data[expId].name == testName) {
						return expId;
					}
				}
			};
			const getCookie = name => {
				const value = `; ${document.cookie}`;
				const parts = value.split(`; ${name}=`);
				if (parts.length === 2) return parts.pop().split(';').shift();
			};
			const getAbGroup = variationId => {
				const myData = window.optimizely.get('data').experiments[getExperimentId()].variations;
				for (let v of myData) {
					if (v.id == variationId) {
						return v.name;
					}
				}
				return false;
			};
			const projectId = window.optimizely.get('data').projectId;
			const endUser = getCookie('optimizelyEndUserId');
			const localStorageKey = 'optimizely_data$$' + endUser + '$$' + projectId + '$$layer_states';
			if (localStorage[localStorageKey]) {
				const lsData = JSON.parse(localStorage[localStorageKey]);
				for (let layer of lsData) {
					if (layer.decision.experimentId == getExperimentId()) {
						return getAbGroup(layer.decision.variationId);
					}
				}
			}
			return false;
		} catch (e) {
			return false;
		}
	}

	function initXgenRenderScript() {
		window.xgen_theme_integration = true;

		class RenderApiError extends Error {
			constructor(message) {
				super(message);
				this.name = 'RenderApiError';
			}
		}
		class xgenUtil {
			setCookie(cname, cvalue, expiration) {
				document.cookie = cname + '=' + cvalue + ';expires=' + expiration + ';path=/';
			}

			getCookie(cname) {
				var name = cname + '=';
				var ca = document.cookie.split(';');
				for (var i = 0; i < ca.length; i++) {
					var c = ca[i];
					while (c.charAt(0) == ' ') {
						c = c.substring(1);
					}
					if (c.indexOf(name) == 0) {
						return c.substring(name.length, c.length);
					}
				}
				return '';
			}
			saveUserToTracker(data) {
				var eventMeta = JSON.parse(JSON.stringify(data));
				delete eventMeta.access_token;
				delete eventMeta.refresh_token;
				delete eventMeta.expiration_date;
				window.xgenTracker.setUserInfo(JSON.stringify(eventMeta));
			}

			forceJsonString(tag) {
				if (typeof tag == 'string') {
					return tag;
				} else {
					return JSON.stringify(tag);
				}
			}

			forceJsonString(tag) {
				if (typeof tag == 'string') {
					return tag;
				} else {
					return JSON.stringify(tag);
				}
			}

			generateUserId() {
				return Math.random().toString(36).substring(2) + new Date().getTime().toString(36);
			}
		}

		class xgenLoader {
			constructor() {
				this.user = {};
				this.abinfo = {};
				this.pageContext = {};
				this.headers = {};
				this.locale = this.getLocale();
			}
			// use collection name to identify
			checkCrawler() {
				const re = new RegExp('bot|crawler|spider|crawling|BingPreview');
				return re.test(navigator.userAgent);
			}

			getUserMetaData() {
				var metaData = window.xgenUtil.getCookie('xgen_meta_data');
				if (metaData) {
					const metaJson = JSON.parse(metaData);
					window.xgenUtil.saveUserToTracker(metaJson);

					if (metaJson.stale) {
						this.headers['x-api-key'] = '6d0371fe7b2bbf74dbdf6dd91e11a8ea';
						this.headers['x-api-secret'] =
							'1a737226bd5142f08278c0183b9af2d08bb79a2cbb9d024400fc595711918f20879604a50736307cfdd183c70d2195b9f39e6dcba7aafdebc66925a307ead4b9';
					} else {
						this.user['access_token'] = metaJson['access_token'];
						this.user['expiration_date'] = metaJson['expiration_date'];
						if (metaJson['access_token']) this.headers['access_token'] = metaJson['access_token'];
						else {
							this.headers['x-api-key'] = '6d0371fe7b2bbf74dbdf6dd91e11a8ea';
							this.headers['x-api-secret'] =
								'1a737226bd5142f08278c0183b9af2d08bb79a2cbb9d024400fc595711918f20879604a50736307cfdd183c70d2195b9f39e6dcba7aafdebc66925a307ead4b9';
						}
					}
					var abinfo = window.xgenUtil.getCookie('xgen_ab_info');
					if (abinfo) this.abinfo = JSON.parse(abinfo);
				} else {
					window.xgenUtil.saveUserToTracker({ stale: true });
					this.headers['x-api-key'] = '6d0371fe7b2bbf74dbdf6dd91e11a8ea';
					this.headers['x-api-secret'] =
						'1a737226bd5142f08278c0183b9af2d08bb79a2cbb9d024400fc595711918f20879604a50736307cfdd183c70d2195b9f39e6dcba7aafdebc66925a307ead4b9';
				}
			}

			getLocale() {
				var localeConfig = JSON.parse(
					'{"jp": {"locale": "ja_JP", "url_pattern": "^/jp/ja.*", "currency": "JPY"}, "us": {"locale": "en_US", "url_pattern": "^/us/en.*", "currency": "USD"}, "it": {"locale": "it_IT", "url_pattern": "^/it/it.*", "currency": "EUR"}, "uk": {"locale": "en_GB", "url_pattern": "^/uk/en_gb.*", "currency": "GBP"}}'
				);
				var locale = '';
				try {
					for (var key in localeConfig) {
						if (localeConfig[key].url_pattern) {
							var urlRegex = new RegExp(localeConfig[key].url_pattern);
							if (urlRegex.test(window.location.pathname)) {
								if (localeConfig[key].hasOwnProperty('locale')) locale = localeConfig[key]['locale'];
							}
						} else if (window.location.pathname.indexOf(key) != -1) {
							if (localeConfig[key].hasOwnProperty('locale')) locale = localeConfig[key]['locale'];
						}
					}
				} catch (err) {
					console.log(
						'Error tracking: GTM locale config is not setup correctly. Customer id: ' +
							'l3z5yo6dslfpqkqmagtxb8spqw4zc7cz'
					);
				}
				return locale;
			}

			// if prevent_override == true, we will not override an existing key
			// otherwise, we will override the key
			savePageContext(key, value, prevent_override = false) {
				if (prevent_override) {
					if (!Object.keys(this.pageContext).includes(key)) this.pageContext[key] = value;
				} else {
					this.pageContext[key] = value;
				}
			}
		}

		window.xgenRecentlyViewed = productID => {
			let recentlyViewed = JSON.parse(localStorage.getItem('xgenRecentlyViewed') || '[]');
			let ruleSet = recentlyViewed.filter(rvItem => rvItem != productID);
			ruleSet = ruleSet.join('|');
			recentlyViewed.unshift(productID);
			recentlyViewed = [...new Set(recentlyViewed)];
			if (recentlyViewed.length > 12) recentlyViewed.pop();
			localStorage.setItem('xgenRecentlyViewed', JSON.stringify(recentlyViewed));
			return ruleSet;
		};

		class xgenTracker {
			constructor() {
				this.observers = {};
				this.userInfo = '';
				this.queuedEvents = [];
				this.ecommerceItems = [];
				this.renderCalled = false;
			}

			// Sends event and returns error (null or error message)
			async sendEvent(event) {
				var err = null;
				if (
					(JSON.parse(this.userInfo || {}).stale === false &&
						window.xgenLoader?.abinfo?.testing_group_name &&
						window.xgenLoader?.user?.session_id) ||
					this.renderCalled
				) {
					var userId = window.xgenLoader.user['user_id'];
					var locale = window.xgenLoader.locale;
					var trackerApi = new URL(
						'https://tracker.xgen.dev/customers/l3z5yo6dslfpqkqmagtxb8spqw4zc7cz/users/' + userId + event.apiPath
					);

					var defaultParams = {
						rec: '1',
						idsite: '9447cb80607e4ba5bf7299730ba5d499',
						url: document.URL,
						urlref: document.referrer,
						locale: locale
						//e_c: getAbGroupForXgen()
					};

					let tmpAbInfo = { ...window.xgenLoader.abinfo };
					tmpAbInfo.testing_group_name = getAbGroupForXgen();

					defaultParams['uid'] = JSON.stringify({
						...JSON.parse(this.userInfo),
						...{ session_id: window.xgenLoader.user.session_id },
						...tmpAbInfo
					});
					var params = { ...defaultParams, ...event.params };

					// const headers = { 'Content-Type': 'application/json', 'cstid': 'l3z5yo6dslfpqkqmagtxb8spqw4zc7cz' };
					// const blob = new Blob([JSON.stringify(params)], headers);

					// navigator.sendBeacon(trackerApi, blob);

					let response = await fetch(trackerApi, {
						method: 'POST',
						keepalive: true,
						headers: { 'Content-Type': 'application/json', 'cstid': 'l3z5yo6dslfpqkqmagtxb8spqw4zc7cz' },
						body: JSON.stringify(params)
					});
					if (response.status >= 400) {
						const body = await response.json();
						err = JSON.stringify(body);
					}
				} else {
					this.queuedEvents.push(event);
					//console.log('Event saved to be fired after render api call: '+ this.userInfo + ' event.params: ' + JSON.stringify(event.params));
				}
				return err;
			}

			trackPageView() {
				var path = '/page-view';
				this.sendEvent({
					params: {
						action_name: 'page_view',
						action_detail: 'page_view',
						action_type: 'ecomm'
					},
					apiPath: path
				}).then(err => {
					if (err != null) {
						window.xgenTracker.trackEvent(
							'Error tracking',
							'Event tracker error',
							'l3z5yo6dslfpqkqmagtxb8spqw4zc7cz',
							err.toString()
						);
					}
				});
			}

			addEcommerceItem(productID, productTitle, tag, price, quantity = 1) {
				this.ecommerceItems.push([productID, productTitle, window.xgenUtil.forceJsonString(tag), price, quantity]);
			}

			trackProductDetailPage(productID, productTitle, tag, price) {
				window.xgenLoader.savePageContext('pdpCode', String(productID));
				var recentlyViewed = window.xgenRecentlyViewed(String(productID));
				window.xgenLoader.savePageContext('recentlyViewed', recentlyViewed);
				var path = '/product-view';
				this.sendEvent({
					params: {
						cvar: JSON.stringify({
							2: ['_pkp', price],
							3: ['_pks', productID],
							4: ['_pkn', productTitle],
							5: ['_pkc', window.xgenUtil.forceJsonString(tag)]
						}),
						action_name: 'product_view',
						action_detail: 'product_view',
						action_type: 'ecomm'
					},
					apiPath: path
				});
			}

			trackProductCategoryPage(category) {
				var path = '/category-view';
				this.sendEvent({
					params: {
						cvar: JSON.stringify({ 5: ['_pkc', category] }),
						action_name: 'category_view',
						action_detail: 'category_view',
						action_type: 'ecomm'
					},
					apiPath: path
				});
			}

			trackAddToCart(productID, productTitle, tag, price) {
				this.addEcommerceItem(productID, productTitle, window.xgenUtil.forceJsonString(tag), price);
				var path = '/product-add';
				this.sendEvent({
					params: {
						ec_items: JSON.stringify(this.ecommerceItems),
						revenue: price,
						action_name: 'product_add',
						action_detail: 'product_add',
						action_type: 'ecomm'
					},
					apiPath: path
				});
			}

			trackPurchase(orderId, totalGrant, subtotal, tax, discount) {
				var item;
				var path = '/product-purchase';
				for (item of this.ecommerceItems) {
					this.sendEvent({
						params: {
							ec_items: JSON.stringify([item]),
							ec_id: JSON.stringify(orderId),
							action_name: 'product_purchase',
							action_detail: 'product_purchase',
							action_type: 'ecomm',
							version: '2'
						},
						apiPath: path
					});
				}
				path = '/purchase-order';
				this.sendEvent({
					params: {
						ec_items: JSON.stringify(this.ecommerceItems),
						revenue: totalGrant,
						ec_id: JSON.stringify(orderId),
						ec_st: subtotal,
						ec_tx: tax,
						ec_dt: JSON.stringify(discount),
						idgoal: '0',
						action_name: 'purchase_order',
						action_detail: 'purchase_order',
						action_type: 'ecomm',
						version: '2'
					},
					apiPath: path
				});
			}

			trackEvent(eventCategory, eventAction, eventName, eventValue) {
				var path = '/error';
				this.sendEvent({
					params: {
						e_c: eventCategory,
						e_a: eventAction,
						e_n: eventName,
						e_v: eventValue,
						action_name: 'event_tracking',
						action_detail: eventAction,
						action_type: eventCategory
					},
					apiPath: path
				});
			}

			trackContentView(contentName, contentPiece, contentTarget) {
				var path = '/element-view';
				this.sendEvent({
					params: {
						c_n: contentName,
						c_p: contentPiece,
						c_t: contentTarget,
						c_i: 'elementViewed',
						action_name: 'content_tracking',
						action_detail: 'element_view',
						action_type: 'smart_element'
					},
					apiPath: path
				});
			}

			trackContentImpression(contentName, contentPiece, contentTarget) {
				var path = '/element-impression';
				this.sendEvent({
					params: {
						c_n: contentName,
						c_p: contentPiece,
						c_t: contentTarget,
						action_name: 'content_tracking',
						action_detail: 'element_impression',
						action_type: 'smart_element'
					},
					apiPath: path
				});
			}

			trackContentInteraction(contentInteraction, contentName, contentPiece, contentTarget) {
				var path = '/element-click';
				this.sendEvent({
					params: {
						c_n: contentName,
						c_p: contentPiece,
						c_t: contentTarget,
						c_i: contentInteraction,
						action_name: 'content_tracking',
						action_detail: 'element_click',
						action_type: 'smart_element'
					},
					apiPath: path
				});
			}

			setUserInfo(userInfo) {
				this.userInfo = userInfo;
			}
		}

		class xgenRender {
			constructor() {
				this.validProduct = 0;
				this.timeStamp = new Date();
				this.userId = window.xgenLoader.user['user_id'];
				window.xgenLoader.savePageContext('pathname', window.location.pathname, true);
				window.xgenLoader.savePageContext('queryString', window.location.search.replace('?', ''), true);
				window.xgenLoader.savePageContext('timestamp', this.timeStamp.getTime().toString());
				this.payload = {
					user: window.xgenLoader.user,
					abinfo: window.xgenLoader.abinfo,
					context: window.xgenLoader.pageContext
				};
				this.headers = {
					'Content-Type': 'application/json',
					'Accept': 'application/json, text/plain, */*',
					...window.xgenLoader.headers
				};
			}

			async renderCallApi(payload) {
				const userId = this.userId;
				const renderApi =
					'https://prediction.xgen.dev/render/customers/l3z5yo6dslfpqkqmagtxb8spqw4zc7cz/users/' +
					userId +
					'?authenticator_id=l3z5yo6dslfpqkqmagtxb8spqw4zc7cz';
				try {
					const response = await fetch(renderApi, {
						method: 'POST',
						headers: this.headers,
						body: JSON.stringify(payload)
					});
					if (!response.ok) {
						const message = `api response: ${response.status}`;
						throw new Error(message);
					}
					const data = await response.json();
					xgenRecsData = data;
					window.dispatchEvent(new Event('xgenRendered'));
					return data;
				} catch (err) {
					const message = `${renderApi} - ${JSON.stringify(payload)} - ${err.toString()}`;
					throw new RenderApiError(message);
				}
			}
			getQueryVariable(variable) {
				var query = window.location.search.substring(1);
				var vars = query.split('&');
				for (var i = 0; i < vars.length; i++) {
					var pair = vars[i].split('=');
					if (pair[0] == variable) {
						return pair[1];
					}
				}
				return false;
			}
			//Replace template variables with prediction data
			parseRecs(htmlStr, recObj) {
				var html = htmlStr.replace(/{{/g, '{{***');
				var arr = html.split(/{{(.+?)?}}/g);
				var withRecs = arr
					.map(function (item) {
						if (item.match(/\*\*\*/g)) {
							var val = item.replace('***', '');
							var attr = recObj[val];
							if (typeof attr == 'object') return JSON.stringify(attr);
							else return attr;
						}
						return item;
					})
					.join('');
				return withRecs;
			}
			//Parse SEML string to HTML string
			parseSEML(seml, dbs) {
				//convert SEML into a document
				var doc = document.createElement('div');
				doc.innerHTML = seml;
				//get <catalog> elements
				var catalogNodes = doc.getElementsByTagName('catalog');
				var catalogList = Array.prototype.slice.call(catalogNodes);
				//iterate through catalogs
				catalogList.forEach(
					function (cat) {
						var repeat = cat.getAttribute('repeat');
						//get source data
						var name = cat.getAttribute('name');
						var db = dbs[name];
						if (db) {
							//expand <rec> elements
							if (/^\d+$/.test(repeat)) {
								var num = parseInt(repeat);
								var recTemp = cat.querySelector('rec');
								var arr = Array.apply(null, Array(num))
									.map(function () {
										return recTemp.outerHTML;
									})
									.join('');
								cat.innerHTML = arr;
							}
							//get <rec> elements
							var recNodes = cat.getElementsByTagName('rec');
							var recList = Array.prototype.slice.call(recNodes);
							//iterate through recs
							recList.forEach(
								function (rec, i) {
									if (db[i]) {
										rec.innerHTML = this.parseb(rec.innerHTML, db[i]);
										this.validProduct += 1;
									}
								}.bind(this)
							);
							if (cat.hasAttribute('remove')) {
								recList.forEach(function (rec, i) {
									cat.parentNode.insertBefore(rec.children[0], cat);
								});
								cat.parentNode.removeChild(cat);
							}
						}
					}.bind(this)
				);
				//return document as string
				return doc.innerHTML;
			}
			parseSEMLv2(seml, element_id, dbs) {
				var doc = document.createElement('div');
				doc.innerHTML = seml;
				var listNodes = doc.querySelectorAll('[xse-type="list"]');
				var listList = Array.prototype.slice.call(listNodes);
				listList.forEach(
					function (item) {
						var catalog = item.getAttribute('catalog') || 'product_catalog';
						var db = dbs[catalog];
						var repeat = parseInt(item.getAttribute('repeat'));
						if (!isNaN(repeat) && repeat > db.length) repeat = db.length;
						if (window.xgenFilterFunc) [db, repeat] = window.xgenFilterFunc(db, repeat, element_id);
						if (db) {
							if (!isNaN(repeat)) {
								var num = parseInt(repeat);
								var recTemp = item.querySelector("[xse-type='rec']");
								if (recTemp) {
									var arr = Array.apply(null, Array(num))
										.map(function () {
											return recTemp.outerHTML;
										})
										.join('');
									item.innerHTML = arr;
								}
							}
							var recNodes = item.querySelectorAll("[xse-type='rec']");
							var recList = Array.prototype.slice.call(recNodes);
							recList.forEach(
								function (rec, i) {
									if (db[i]) {
										rec.innerHTML = this.parseRecs(rec.innerHTML, db[i]);
										this.validProduct += 1;
									}
								}.bind(this)
							);
						}
					}.bind(this)
				);
				// adding smart element's id to each of the href attributes in links
				Array.prototype.slice.call(doc.querySelectorAll('[href]')).forEach(function (elem) {
					if (elem.href.includes('?')) {
						elem.href += '&xse=' + element_id;
					} else {
						elem.href += '?xse=' + element_id;
					}
				});
				return doc.innerHTML;
			}
			addContentTracking(elementContainer, sm, recs) {
				var contentName = sm.element_id;
				var contentPiece = recs
					.slice(0, this.validProduct)
					.map(function (rec) {
						return rec['prod_name'];
					})
					.toString();
				var contentTarget = recs
					.slice(0, this.validProduct)
					.map(function (rec) {
						return rec['prod_code'];
					})
					.toString();
				window.xgenTracker.trackContentImpression(contentName, contentPiece, contentTarget);
				var recList =
					sm.seml_version === '2.0'
						? elementContainer.querySelectorAll("[xse-type='rec']")
						: elementContainer.querySelectorAll('rec');
				recList.forEach(function (node, index) {
					node.addEventListener('click', function () {
						window.xgenTracker.trackContentInteraction(
							'elementClicked',
							contentName,
							recs[index]['prod_code'],
							contentTarget
						);
					});
				});
				if (document.readyState === 'complete') {
					this.observeElementsViews(elementContainer, contentName, contentPiece, contentTarget);
				} else {
					document.addEventListener('readystatechange', () => {
						if (document.readyState === 'complete') {
							this.observeElementsViews(elementContainer, contentName, contentPiece, contentTarget);
						}
					});
				}
			}

			observeElementsViews(elementContainer, contentName, contentPiece, contentTarget) {
				if (this.isDisplayed(elementContainer) && this.isInViewport(elementContainer)) {
					window.xgenTracker.trackContentView(contentName, contentPiece, contentTarget);
				} else {
					const intersectionObserver = this.createIntersectionObserver(
						elementContainer,
						contentName,
						contentPiece,
						contentTarget
					);
					const resizeObserver = this.createResizeObserver(elementContainer, contentName, contentPiece, contentTarget);
					intersectionObserver.observe(elementContainer);
					resizeObserver.observe(elementContainer);
					window.xgenTracker.observers[elementContainer.id] = [intersectionObserver, resizeObserver];
				}
			}

			createResizeObserver(elementContainer, contentName, contentPiece, contentTarget) {
				const resizeObserver = new ResizeObserver(entries => {
					entries.forEach(entry => {
						if (this.isDisplayed(entry.target) && this.isInViewport(entry.target)) {
							window.xgenTracker.trackContentView(contentName, contentPiece, contentTarget);
							window.xgenTracker.observers[elementContainer.id].forEach(observer => {
								observer.disconnect();
							});
						}
					});
				});
				return resizeObserver;
			}

			createIntersectionObserver(elementContainer, contentName, contentPiece, contentTarget) {
				const options = {
					root: null,
					threshold: 0.4,
					rootMargin: '0px'
				};

				const intersectionObserver = new IntersectionObserver(entries => {
					entries.forEach(entry => {
						if (this.isDisplayed(entry.target) && entry.isIntersecting) {
							window.xgenTracker.trackContentView(contentName, contentPiece, contentTarget);
							window.xgenTracker.observers[elementContainer.id].forEach(observer => {
								observer.disconnect();
							});
						}
					});
				}, options);

				return intersectionObserver;
			}

			isInViewport(element) {
				var rectangleContainer = element.getBoundingClientRect();
				return (
					rectangleContainer.top >= 0 &&
					rectangleContainer.left >= 0 &&
					rectangleContainer.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
					rectangleContainer.right <= (window.innerWidth || document.documentElement.clientWidth)
				);
			}

			isDisplayed(element) {
				return element.clientWidth > 0 && element.clientHeight > 0;
			}

			//Input executable JS into HTML
			addScript(codeStr) {
				var newScript = document.createElement('script');
				var inlineScript = document.createTextNode(codeStr);
				newScript.appendChild(inlineScript);
				document.body.appendChild(newScript);
			}
			//Render Smart Element on page
			renderElement(sm, recs) {
				//get hook element
				try {
					var hookElem = document.querySelector(sm.element_hook);
					if (
						(sm.enabled && sm.enabled === 'true') ||
						(sm.element_id == this.getQueryVariable('xse_preview') &&
							sm.element_preview &&
							sm.element_preview === 'true')
					) {
						//parse seml to html
						var seml = sm.element_style
							? '<style>' + sm.element_style + '</style>' + sm.element_body
							: sm.element_body;
						// Change images to prevent 404
						if (!seml || typeof seml != 'string' || String.prototype.replaceAll == undefined) {
							throw JSON.stringify({
								elem: sm.element_id,
								seml: typeof seml != 'string' ? typeof seml : seml.substr(0, 10),
								body: typeof sm.element_body != 'string' ? typeof sm.element_body : sm.element_body.substr(0, 10),
								style: typeof element_style != 'string' ? typeof element_style : element_style.substr(0, 10),
								replace: Boolean(String.prototype.replaceAll)
							});
						}
						seml = seml.replaceAll('<img', '<xse-temp-img');
						seml = seml.replaceAll('</img', '</xse-temp-img');
						seml = seml.replaceAll('<image', '<xse-temp-img');
						seml = seml.replaceAll('</image', '</xse-temp-img');
						seml = seml.replaceAll('src="{{image', 'xse-temp-src="{{image');
						seml = seml.replaceAll("src='{{image", "xse-temp-src='{{image");
						var html;
						if (sm.seml_version && sm.seml_version === '2.0') {
							html = this.parseSEMLv2(seml, sm.element_id, { product_catalog: recs });
						} else {
							html = this.parseSEML(seml, { product_catalog: recs });
						}
						//get smart element postion relative to hook element
						var positions = JSON.parse('{"above": "beforeBegin","below": "afterEnd","replace":"replace"}');
						var smPos = positions[sm.element_position];
						//render smart element in correct place
						var smartElement = document.createElement('div');
						smartElement.classList.add('XGen_SmartElement');
						smartElement.id = `XSE-${sm.element_id}`;
						smartElement.innerHTML = html;
						this.addContentTracking(smartElement, sm, recs);
						if (smPos === 'replace') {
							hookElem.innerHTML = '';
							hookElem.appendChild(smartElement);
						} else hookElem.insertAdjacentElement(smPos, smartElement);
						// Change images back to normal
						document.querySelectorAll('xse-temp-img').forEach(e => {
							var newElemHTML = e.outerHTML;
							newElemHTML = newElemHTML.replaceAll('xse-temp-img', 'img');
							newElemHTML = newElemHTML.replaceAll('xse-temp-src', 'src');
							e.outerHTML = newElemHTML;
						});
						//add element's javascript
						if (sm.element_script) this.addScript(sm.element_script);
					}
				} catch (err) {
					window.xgenTracker.trackEvent('Error render', 'cannot render Xgen element', err.toString());
				}
			}
			// Save recommendation images to cache
			checkAndCacheImages(recs) {
				recs.forEach(function (rec) {
					let image = new Image();
					image.src = rec.image;
					if (rec.image_alt) {
						let imageAlt = new Image();
						imageAlt.src = rec.image_alt;
					}
				});
			}
			// we may have received the recommendations before the hook is on
			// the page. We check until it's ready
			renderWhenReady(sm, recs) {
				var hookElem = document.querySelector(sm.element_hook);
				if (!hookElem) {
					setTimeout(
						function () {
							if (document.readyState == 'complete') {
								this.renderWhenReady(sm, recs);
							}
						}.bind(this),
						30
					);
				} else {
					this.renderElement(sm, recs);
				}
			}
			processRender(data) {
				data.forEach(
					function (obj) {
						if (obj.prediction.length > 0) {
							this.checkAndCacheImages(obj.prediction);
							this.renderWhenReady(obj.element, obj.prediction);
						} else if ('vmfqqn2hg7dl3lxylw3vgbkqcsj476o1' === 'l3z5yo6dslfpqkqmagtxb8spqw4zc7cz') {
							// send event for yamamay only
							window.xgenTracker.trackEvent(
								'Error tracking',
								`empty predictions for ${obj.element.element_id}`,
								'l3z5yo6dslfpqkqmagtxb8spqw4zc7cz'
							);
						}
					}.bind(this)
				);
			}
			// Render recommendation result to the page
			renderPage(data) {
				var parentData = [];
				var childData = [];
				// Sort each object as parent/child data
				data.forEach(function (obj) {
					if (obj.error) {
						throw new RenderApiError(obj.error);
					}
					if (obj.element.embedded_type == 'child') {
						childData.push(obj);
					} else {
						parentData.push(obj);
					}
				});
				// render parent data
				this.processRender(parentData);
				// render child data
				this.processRender(childData);
			}
			// Save User data result to the cookie
			saveCookie(data, stale = false) {
				// Convert user_data JSON into String and store in cookie
				data['stale'] = stale;
				if (stale) {
					window.xgenUtil.setCookie('xgen_meta_data', JSON.stringify(data), new Date(expiration).toUTCString());
				} else {
					let sessionExpiration = new Date();
					sessionExpiration.setTime(sessionExpiration.getTime() + 1800000);
					window.xgenUtil.setCookie('xgen_session_id', data.session_id, sessionExpiration.toUTCString());
					let abExpiration = new Date();
					abExpiration.setTime(abExpiration.getTime() + 34160000000);
					const params = new Proxy(new URLSearchParams(window.location.search), {
						get: (searchParams, prop) => searchParams.get(prop)
					});

					window.xgenUtil.setCookie(
						'xgen_ab_info',
						JSON.stringify({
							ab_test_id: data.ab_test_id,
							percent: data.percent,
							testing_group_id: data.testing_group_id,
							testing_group_name: params.xse_abtest || data.testing_group_name
						}),
						abExpiration
					);
					delete data.session_id;
					delete data.ab_test_id;
					delete data.percent;
					delete data.testing_group_id;
					delete data.testing_group_name;
					window.xgenUtil.saveUserToTracker(data);
					var expiration = data.expiration_date;
					window.xgenUtil.setCookie('xgen_meta_data', JSON.stringify(data), new Date(expiration).toUTCString());
				}
			}
			// Render main function
			async render() {
				if (window.XGEN_TOOL_USED) {
					// extension is being used so we do nothing.
					// Prevents live elements from showing up while using the tool
					return;
				}
				try {
					const response = await this.renderCallApi(this.payload);
					var userData = response.user_data;
					var renderData = response.render_data;

					window.xgenLoader.user.session_id = userData.session_id;
					window.xgenLoader.abinfo = {
						ab_test_id: userData.ab_test_id,
						percent: userData.percent,
						testing_group_id: userData.testing_group_id,
						testing_group_name: userData.testing_group_name
					};

					// Update user data to cookie
					this.saveCookie(userData);
					if (renderData.length > 0) {
						// Render pages
						this.renderPage(renderData);
					}
				} catch (err) {
					if (err instanceof RenderApiError) {
						if (
							['Failed to fetch', 'NetworkError when attempting to fetch resource', 'cancelled'].includes(
								/TypeError: (?<errorMessage>.+)$/.exec(err.message)?.groups.errorMessage
							)
						) {
							window.xgenTracker.trackEvent(
								'Error tracking',
								'api cancelled',
								'l3z5yo6dslfpqkqmagtxb8spqw4zc7cz',
								err.toString()
							);
						} else {
							window.xgenTracker.trackEvent(
								'Error tracking',
								'render api failed',
								'l3z5yo6dslfpqkqmagtxb8spqw4zc7cz',
								err.toString()
							);
							this.saveCookie({}, true);
						}
					} else {
						window.xgenTracker.trackEvent(
							'Error tracking',
							'render process failed',
							'l3z5yo6dslfpqkqmagtxb8spqw4zc7cz',
							err.toString()
						);
					}
				}
			}
		}

		window.xgenUtil = new xgenUtil();
		window.xgenTracker = new xgenTracker();
		window.xgenLoader = new xgenLoader();
		if (!window.xgenLoader.checkCrawler()) {
			async function startRenderLogic() {
				var cookieExpTime = new Date();
				// 13 months of expiration, same as what Matomo cookie expiration is.
				cookieExpTime.setTime(cookieExpTime.getTime() + 3600 * 1000 * 24 * 395);
				// if the flag is set to false, keep the old way of getting user_id.
				if ('true' == 'false') {
					window.xgenLoader.user['user_id'] = this.getVisitorId() || 'unknown';
				} else {
					var metaData = window.xgenUtil.getCookie('xgen_meta_data');
					var metaJson;
					// check for empty string in case metaData is empty, so JSON.parse() doesn't throw an error.
					if (metaData != '') metaJson = JSON.parse(metaData);

					// If the current user_id is still using the old matomo user_id,
					if (metaJson != undefined && metaJson['user_id'] != undefined && metaJson['user_id'].length == 16) {
						// If it is logging in, switch to the new user_id generation workflow.
						if (metaJson['action'] == 'User Login' || metaJson['action'] == 'action_login') {
							window.xgenLoader.user['user_id'] = window.xgenUtil.generateUserId();
							window.xgenUtil.setCookie(
								'xgen_user_id',
								window.xgenLoader.user['user_id'],
								cookieExpTime.toUTCString()
							);
						} else {
							// else, keep the old_id format until the session expires.
							window.xgenLoader.user['user_id'] = this.getVisitorId() || 'unknown';
						}
						// If it is using the new user_id already, follow the new user_id generation workflow.
					} else {
						if (window.xgenUtil.getCookie('xgen_user_id') != '') {
							window.xgenLoader.user['user_id'] = window.xgenUtil.getCookie('xgen_user_id');
							window.xgenLoader.user['session_id'] = window.xgenUtil.getCookie('xgen_session_id');
							if (
								JSON.parse(window.xgenUtil.getCookie('xgen_meta_data') || '{}')?.user_type == 'new_user' &&
								window.xgenLoader.user['session_id'] != ''
							) {
								window.xgenLoader.user['user_type'] = 'new_user';
							} else window.xgenLoader.user['user_type'] = 'return_user';
						} else {
							window.xgenLoader.user['user_id'] = window.xgenUtil.generateUserId();
							window.xgenLoader.user['user_type'] = 'new_user';
							window.xgenUtil.setCookie(
								'xgen_user_id',
								window.xgenLoader.user['user_id'],
								cookieExpTime.toUTCString()
							);
						}
					}
				}
				window.xgenLoader.getUserMetaData();
				window.xgenTracker.trackPageView();

				console.log('before custom script');

				// Customized tracking and contextual ruleset script for GTM clients
				if (typeof window.xgenCustomScript == 'function') window.xgenCustomScript();

				console.log('after custom script');

				const renderObject = new xgenRender();
				await renderObject.render();

				// Fire all queued events after render call
				window.xgenTracker.renderCalled = true;
				for (queuedEvent of window.xgenTracker.queuedEvents) {
					window.xgenTracker.sendEvent(queuedEvent);
				}
			}
			startRenderLogic();
		}
	}

	function waitForElementAle(selector, callback) {
		if (!document.querySelector(selector)) {
			setTimeout(waitForElementAle.bind(null, selector, callback), 100);
		} else {
			callback();
		}
	}
	async function waitForElement(selector, timeout = 5000, interval = 100) {
		const rafAsync = () => new Promise(resolve => requestAnimationFrame(resolve));
		const sleep = () => new Promise(r => setTimeout(r, interval));
		const start = Date.now();
		while (!document.querySelector(selector)) {
			if (interval) await sleep();
			await rafAsync();
		}
		return document.querySelector(selector);
	}

	(function () {
		//xgen script
		if (window.XGEN_TOOL_USED) {
			// extension is being used
			return;
		}
		window.xgenCustomScript = function () {
			function changeGucciRecLinks(page) {
				const gucciSelector = '.certona-recommendation-v2__slide';
				let spaReloader = new MutationObserver(records => {
					records.forEach(record => {
						if (
							Array.from(record.addedNodes).find(node => {
								if (node.nodeType === Node.ELEMENT_NODE && node.matches(gucciSelector)) return true;
							})
						) {
							let carousel = document.querySelector(gucciSelector)?.parentElement;
							if (!carousel) return;
							let links = carousel.querySelectorAll('.js-ga-track');
							for (let link of links) {
								if (!link.href.includes('?existing=')) {
									link.href += `?existing=${page}`;
								}
							}
						}
					});
				});

				if (document.readyState === 'loaded') {
					observeSpaReloader(spaReloader);
				} else {
					document.addEventListener(
						'readystatechange',
						() => {
							observeSpaReloader(spaReloader);
						},
						{ once: true }
					);
				}
			}

			function observeSpaReloader(spaReloader) {
				spaReloader.observe(document.body, {
					subtree: true,
					childList: true
				});
			}

			try {
				const pdpPage = window.dataLayer.find(dl => dl.event === 'viewProductDetail');
				const wishList = window.location.pathname.includes('/wishlist/saved-items');
				const cartPage =
					window.location.pathname.includes('/cart') &&
					window.dataLayer.find(dl => dl.event === 'shoppingBagDetails')?.ecommerce?.cart?.products?.length > 0;
				if (pdpPage) changeGucciRecLinks('pdp');
				if (wishList) changeGucciRecLinks('wishlist');
				if (cartPage) changeGucciRecLinks('cart');
			} catch (err) {
				window.xgenTracker.trackEvent('Error tracking', 'GA tracking script error', err.toString());
			}

			// Tracking
			try {
				const pdpDl = window.dataLayer.find(dl => dl.event === 'viewProductDetail');
				const purchaseDl = window.dataLayer.find(dl => dl.event === 'purchase');
				if (pdpDl) {
					const product = pdpDl.ecommerce.detail.products[0];
					const productInfo = [product.id, product.name, { currency_code: window.siteCurrency }, product.price];
					window.xgenTracker.trackProductDetailPage(...productInfo);
					document.querySelector('.shopping-bag-cta')?.addEventListener('click', () => {
						window.xgenTracker.trackAddToCart(...productInfo);
					});

					//Track Google Rec Views and clicks
					function observeElementsViews(elementContainer, contentName, contentPiece, contentTarget) {
						if (isDisplayed(elementContainer) && isInViewport(elementContainer)) {
							window.xgenTracker.trackContentView(contentName, contentPiece, contentTarget);
						} else {
							const intersectionObserver = createIntersectionObserver(
								elementContainer,
								contentName,
								contentPiece,
								contentTarget
							);
							const resizeObserver = createResizeObserver(
								elementContainer,
								contentName,
								contentPiece,
								contentTarget
							);
							intersectionObserver.observe(elementContainer);
							resizeObserver.observe(elementContainer);
							window.xgenTracker.observers[elementContainer.id] = [intersectionObserver, resizeObserver];
						}
					}

					function createIntersectionObserver(elementContainer, contentName, contentPiece, contentTarget) {
						const options = {
							root: null,
							threshold: 0.4,
							rootMargin: '0px'
						};

						const intersectionObserver = new IntersectionObserver(entries => {
							entries.forEach(entry => {
								if (isDisplayed(entry.target) && entry.isIntersecting) {
									window.xgenTracker.trackContentView(contentName, contentPiece, contentTarget);
									window.xgenTracker.observers[elementContainer.id].forEach(observer => {
										observer.disconnect();
									});
								}
							});
						}, options);

						return intersectionObserver;
					}

					function createResizeObserver(elementContainer, contentName, contentPiece, contentTarget) {
						const resizeObserver = new ResizeObserver(entries => {
							entries.forEach(entry => {
								if (isDisplayed(entry.target) && isInViewport(entry.target)) {
									window.xgenTracker.trackContentView(contentName, contentPiece, contentTarget);
									window.xgenTracker.observers[elementContainer.id].forEach(observer => {
										observer.disconnect();
									});
								}
							});
						});
						return resizeObserver;
					}
					function isInViewport(element) {
						var rectangleContainer = element.getBoundingClientRect();
						return (
							rectangleContainer.top >= 0 &&
							rectangleContainer.left >= 0 &&
							rectangleContainer.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
							rectangleContainer.right <= (window.innerWidth || document.documentElement.clientWidth)
						);
					}
					function isDisplayed(element) {
						return element.clientWidth > 0 && element.clientHeight > 0;
					}

					waitForElement('[data-certona="certonaRecommendation_v2"] .certona-recommendation-v2__slide').then(
						element => {
							if (!element) return;
							const googleContainer = document.querySelector('[data-certona="certonaRecommendation_v2"]');
							const googleRecs = document.querySelectorAll(
								'[data-certona="certonaRecommendation_v2"] .certona-recommendation-v2__slide'
							);
							for (let rec of googleRecs) {
								rec.addEventListener('click', e => {
									if (e.target.matches('.save')) return;
									window.xgenTracker.trackContentInteraction(
										'google-element-click',
										'Gucci Google Recs PDP',
										'',
										''
									);
								});
							}
							googleContainer.id = 'certonaRecommendation_v2_tracking';
							observeElementsViews(googleContainer, 'Gucci Google Recs PDP', '', '');
						}
					);
				} else if (purchaseDl) {
					const purchaseInfo = {
						...purchaseDl.ecommerce.purchase.actionField,
						products: purchaseDl.ecommerce.purchase.products
					};

					let pastTransactions = localStorage.getItem('xgRecentTransactions')?.split(',');
					if (!pastTransactions?.includes(purchaseInfo.id)) {
						purchaseInfo.products.forEach(product => {
							window.xgenTracker.addEcommerceItem(
								product.id,
								product.name,
								{ currency_code: window.location.pathname.startsWith('/jp/ja') ? 'JPY' : window.currency },
								product.price,
								product.quantity
							);
						});
						const total =
							parseFloat(purchaseInfo.revenue) + parseFloat(purchaseInfo.shipping) + parseFloat(purchaseInfo.tax);
						window.xgenTracker.trackPurchase(purchaseInfo.id, total, purchaseInfo.revenue, purchaseInfo.tax);
						localStorage.setItem(
							'xgRecentTransactions',
							pastTransactions ? [...pastTransactions, purchaseInfo.id].join(',') : purchaseInfo.id
						);
					}
				}
			} catch (err) {
				window.xgenTracker.trackEvent('Error tracking', 'tracking script error', err.toString());
			}
			// Page Types
			try {
				let queryParams = {};
				const cartNotEmpty =
					window.dataLayer.find(dl => dl.event === 'shoppingBagDetails')?.ecommerce?.cart?.products.length > 0;
				const recentlyViewed = JSON.parse(localStorage.getItem('xgenRecentlyViewed') || '[]');
				if (cartNotEmpty) {
					queryParams['cartNotEmpty'] = 'true';
				}

				if (recentlyViewed.length < 2 && location.pathname.indexOf('-p-') !== -1) {
					queryParams['xse_ruleset'] = 1;

					try {
						const category = [...document.querySelectorAll('[type="application/ld+json"]')].reduce((arr, ld) => {
							const content = JSON.parse(ld.innerHTML.replaceAll(/\n|\t/g, ''));
							if (content['@type'] == 'BreadcrumbList') {
								console.log(content.itemListElement);
								arr = content.itemListElement?.map(el => el.item.name.toLowerCase())[0] || '';
							}
							return arr;
						}, '');

						window.xgenLoader.savePageContext('xt_category', category);
					} catch (e) {
						window.xgenLoader.savePageContext('xt_category', '');
						console.log('error getting categories from json+ld');
						window.xgenTracker.trackEvent('Error tracking', 'error getting categories from json+ld', e.toString());
					}
				}

				window.xgenLoader.savePageContext(
					'queryString',
					window.location.search.replace('?', '') +
						(window.location.search == '' ? '' : '&') +
						Object.entries(queryParams)
							.map(param => param.join('='))
							.join('&')
				);
			} catch (err) {
				window.xgenTracker.trackEvent('Error tracking', 'contextual pagetype error', err.toString());
			}

			// Contextual Rulesets
			try {
				const pdpDl = window.dataLayer.find(dl => dl.event === 'viewProductDetail');
				const cartPage =
					window.location.pathname.includes('/cart') &&
					window.dataLayer.find(dl => dl.event === 'shoppingBagDetails')?.ecommerce?.cart?.products?.length > 0;
				if (pdpDl) {
					let [gender] = pdpDl.ecommerce.detail.products[0].category
						.toLowerCase()
						.split('/')
						.map(segment => `/${segment}/`);
					window.xgenLoader.savePageContext('xt_gender', gender);
				}
				if (location.pathname.includes('-c-')) {
					const handle = location.pathname.split('/').pop();
					const category = handle.split('-c-')[0].replaceAll('-', ' ');
					window.xgenLoader.savePageContext('xt_category', category);
				}
				if (cartPage) {
					const cartItems = window.dataLayer.find(dl => dl.event === 'shoppingBagDetails')?.ecommerce?.cart?.products;
					const itemIds = [];
					for (let item of cartItems) {
						itemIds.push(item.id);
					}
					window.xgenLoader.savePageContext('exclude', Array.from(new Set(itemIds)).join('|'));
				}
			} catch (err) {
				window.xgenTracker.trackEvent('Error tracking', 'contextual ruleset error', err.toString());
			}
		};

		function mapXgenPredictions(preds) {
			let toMap = (preds && preds.render_data && preds.render_data[0] && preds.render_data[0].prediction) || [];
			return toMap.map(item => {
				return {
					id: item.prod_code,
					details: {
						currency: item.price_currency,
						image_url: item.image,
						name: item.prod_name,
						unit_price: item.price,
						url: item.link
					}
				};
			});
		}

		window.getXgenPredictions = function () {
			return new Promise((resolve, reject) => {
				if (xgenRecsData) {
					resolve(mapXgenPredictions(xgenRecsData));
					return true;
				}

				window.addEventListener('xgenRendered', function () {
					resolve(mapXgenPredictions(xgenRecsData));
				});
			});
		};

		if (!location.pathname.includes('-p-')) {
			initXgenRenderScript();
		} else {
			let startInterval = setInterval(() => {
				const pdpDl = window.dataLayer.find(dl => dl.event === 'viewProductDetail');
				if (pdpDl) {
					clearInterval(startInterval);
					initXgenRenderScript();
				}
			}, 250);
		}
	})();
})();
